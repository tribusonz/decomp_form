# はじめに

　筆者が初等関数の数値計算について様々な解析・研究をするに，指数分解にある変数xは分解能 *resolving power* に従っていることを突き止めた。これは複素解析学 *complex analytics* でいうところのノルム *norm* $\sqrt{x^2+y^2}$ と類似な関係を持ち，その周期性は累乗根 *power root* について有利関数近似 *rational function approximation* に等しくなる。  
　これにはリーマン球面 *riemann sphere* で言及されるような多価関数 *manyvalued function* があり，無論，発見した対象も対数関数 *logarithmic function* であった。われわれはこれを基数相補法 *radix complementation method* と呼んでいる。  
　基数相補法でこれは有理近似による展開，いうなればn次連立方程式 *nth order simultaneous equations* によっている。この関係は特徴的で，条件数 *condition number* こそスケーリング係数 *scaling factor* としてn次方程式が連立しているものの，解析接続 *analytic continuation* されるような多価性は持っていない。n次方程式が係数について連立しているのである。これは，ある分解能に従っていては方程式は形を変えず基数に相補して解を導出している。解析に現れる変数は，通常数学で求めるものよりも，物理学の傾向が強い。  
　では逆関数をn次連立方程式の観点から見てみる。対数は0と1からなる1から始まる1と2の世界であるが，逆関数 $e_{2}(x)$ でもこの関係は明らかであろう。  

　`Ruby`で`map`を使い、これを示す。`map`は昔からあるメソッドであるが，最新の`Python`でもイテレーション機能として採用されている。  

```
# t1: 0.0 <= x <= 1.0
pp t1 = (0..10).step(1).map{|x| x = x/10.0; Math.exp(x * Math.log(2))}
#=> [1.0,
#=>  1.0717734625362931,
#=>  1.148698354997035,
#=>  1.2311444133449163,
#=>  1.3195079107728942,
#=>  1.414213562373095,
#=>  1.515716566510398,
#=>  1.624504792712471,
#=>  1.7411011265922482,
#=>  1.8660659830736148,
#=>  2.0]
```

　このような特性を持つなら，$1 \leq x \leq 2, 2 \leq x \leq 4, 4 \leq x \leq 8\ldots$は倍率の関係に有効である。

```
# t2: 1.0 <= x <= 2.0
pp t2 = (10..20).step(1).map{|x| x = x/10.0; Math.exp(x * Math.log(2))}
#=> [2.0,
#=>  2.1435469250725863,
#=>  2.29739670999407,
#=>  2.4622888266898326,
#=>  2.6390158215457884,
#=>  2.82842712474619,
#=>  3.031433133020796,
#=>  3.249009585424942,
#=>  3.4822022531844965,
#=>  3.7321319661472296,
#=>  4.0]

# t3: 2.0 <= x <= 4.0
pp t3 = (20..40).step(2).map{|x| x = x/10.0; Math.exp(x * Math.log(2))}
#=> [4.0,
#=>  4.5947934199881395,
#=>  5.278031643091577,
#=>  6.062866266041592,
#=>  6.964404506368992,
#=>  7.999999999999998,
#=>  9.189586839976279,
#=>  10.556063286183152,
#=>  12.125732532083184,
#=>  13.928809012737984,
#=>  15.999999999999998]

# t4: 4.0 <= x < 8.0
pp t4 = (40..80).step(4).map{|x| x = x/10.0; Math.exp(x * Math.log(2))}
#=> [15.999999999999998,
#=>  21.112126572366307,
#=>  27.857618025475972,
#=>  36.75834735990512,
#=>  48.50293012833272,
#=>  63.99999999999998,
#=>  84.4485062894652,
#=>  111.43047210190386,
#=>  147.03338943962044,
#=>  194.0117205133309,
#=>  255.99999999999994]
```

　ただし分解率 *decomposition rate* はこれに及ばない。基数が重なるにつれ多価性はどんどん相関しなくなる。解析学の見る尺度を変えれば，これは悪条件 *ill-conditioned* に当てはまる。

```
# [Check Decomposition Rate for Relationship]
p t1.zip(t2).map{|a, b| a / b}
#=> [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]

pp t1.zip(t3).map{|a, b| a / b}
#=> [0.25,
#=>  0.23325824788420188,
#=>  0.21763764082403106,
#=>  0.2030630990890589,
#=>  0.18946457081379978,
#=>  0.1767766952966369,
#=>  0.1649384888466118,
#=>  0.15389305166811457,
#=>  0.1435872943746294,
#=>  0.13397168281703667,
#=>  0.12500000000000003]

pp t1.zip(t4).map{|a, b| a / b}
#=> [0.06250000000000001,
#=>  0.050765774772264724,
#=>  0.04123462221165295,
#=>  0.03349292070425916,
#=>  0.02720470510300389,
#=>  0.022097086912079615,
#=>  0.017948411796828677,
#=>  0.01457864049276262,
#=>  0.011841535675862488,
#=>  0.00961831572925716,
#=>  0.007812500000000002]
```

　基数で割ると，相関は単射性 *injection* よりもむしろ倍率による傾斜傾向があることが分かる。

```
# [Check Decomposition Rate for radix]
pp t2.map{|x| 2 / x}
#=> [1.0,
#=>  0.9330329915368074,
#=>  0.8705505632961241,
#=>  0.8122523963562355,
#=>  0.7578582832551991,
#=>  0.7071067811865476,
#=>  0.6597539553864472,
#=>  0.6155722066724582,
#=>  0.5743491774985175,
#=>  0.5358867312681466,
#=>  0.5]

pp t3.map{|x| 4 / x}
#=> [1.0,
#=>  0.8705505632961242,
#=>  0.7578582832551991,
#=>  0.6597539553864472,
#=>  0.5743491774985175,
#=>  0.5000000000000001,
#=>  0.4352752816480621,
#=>  0.3789291416275996,
#=>  0.3298769776932236,
#=>  0.2871745887492588,
#=>  0.25000000000000006]

pp t4.map{|x| 16 / x}
#=> [1.0000000000000002,
#=>  0.7578582832551991,
#=>  0.5743491774985175,
#=>  0.43527528164806206,
#=>  0.32987697769322366,
#=>  0.2500000000000001,
#=>  0.18946457081379983,
#=>  0.14358729437462942,
#=>  0.10881882041201556,
#=>  0.08246924442330592,
#=>  0.06250000000000001]
```

　どうしてこうなのか，主観を変えて剰余から見てみる。基数によって分解能に従っているのは明らかなのだから，基数の商と剰余の関係も成り立つはずである。

```
# [Check Decomposition Rate for divmod]

pp t2.map{|x| 2.divmod(x)}
#=> [[1, 0.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0],
#=>  [0, 2.0]]

pp t3.map{|x| 4.divmod(x)}
#=> [[1, 0.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0],
#=>  [0, 4.0]]

pp t4.map{|x| 16.divmod(x)}
#=> [[1, 1.7763568394002505e-15],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0],
#=>  [0, 16.0]]
```

　ここで面白い発見があった。指数の基数は変数xとの相補で成り立っているのではなく，むしろ最大公約数・最小公倍数で成り立っているのである。また，仮数がちょうど`1.0`である場合，基数の相関とは一致していない。対数の基数を敢えて床関数 *floor function* に基づくとすると，指数の基数は天井関数 *ceiling function* に基づくとするということになる。

指数分解における対数と指数の相関を以下に示す:

対数と指数の相関  
|関係|対数|指数|
|:--:|:--:|:--:|
|基数|xとの相補|xの最大公約数と最小公倍数|
|近接整数|床関数|天井関数|
|分解公式|分解能と分解率|商と剰余|

　基数相補法は物理学の傾向が強く，単純数式に現わすとなると説明のために一冊の本が書けそうな規模である。実際，対数関数の分解公式をまとめようにも  

$f(x)\equiv s\subseteq (ab)=\log_b^{\text{rcm}_a^{\text{Fraction}|x|}}+\text{rcm}_a^{\text{Exponent}|x|}, a=b=\text{Radix}$  

　といった専門数学でも難しい式が書けてしまう。  

